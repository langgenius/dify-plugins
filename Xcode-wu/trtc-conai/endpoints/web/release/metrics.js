let metricsData = { asr_latency: [], llm_network_latency: [], llm_first_token: [], tts_network_latency: [], tts_first_frame_latency: [], tts_discontinuity: [], interruption: [] };
function recordMetric(metric, value, roundId) { if (metricsData.hasOwnProperty(metric)) metricsData[metric].push({ value, roundId }); }
function resetMetrics() { metricsData = { asr_latency: [], llm_network_latency: [], llm_first_token: [], tts_network_latency: [], tts_first_frame_latency: [], tts_discontinuity: [], interruption: [] }; }
function displayLatencyStatistics() { try { const statistics = {}; const metricLabels = { asr_latency: 'asr', llm_first_token: 'llm', tts_first_frame_latency: 'tts ' }; Object.keys(metricsData).forEach(metric => { const values = metricsData[metric].map(i=>i.value); if (values.length) { const sum = values.reduce((a,b)=>a+b,0); statistics[metric] = { count: values.length, avg: Math.round(sum/values.length), min: Math.min(...values), max: Math.max(...values) }; } }); let table = "metrics(ms):\n"; table += "ðŸ•¹ï¸  | avg | min | max | *\n"; Object.keys(statistics).forEach(metric => { const s = statistics[metric]; const label = metricLabels[metric]; if (!label) return; table += `${label} | ${s.avg} | ${s.min} | ${s.max} | ${s.count}\n`; }); if (Object.keys(statistics).length === 0) table = "No latency metrics recorded"; addSystemMessage(table); } catch (e) {} }

